# Лабораторная работа №4

## Цель

Данная работа нацелена на развитие навыков студента в применении:
- семантики перемещения
- RAII
- умных указателей

## Теория

Умные указатели - это указатели с явным и строгим определением владельца области памяти; это
абстракция над "сырыми" указателями, которая привносит в их определение понятие владения памятью.

Умные указатели призваны упростить управление памятью в C++ за счёт встроенных в язык механизмов
работы с классами, принципов RAII и энкапсуляции. В общем случае указатель становится объектом, и
управление его зарезервированной областью памяти сводится к работе с конструкторами и деструкторами.

Умные указатели в библиотеке языка C++ представлены классами:
- `std::unique_ptr`
- `std::shared_ptr`
- `std::weak_ptr`

и соответственно представляют:
- уникальное владение памятью (нет общей памяти)
- общее владение памятью

При уникальном владении памятью не допускается доступ к области памяти из различных участков кода за
счёт запрета копирования указателя. Это может быть полезно, когда применяется подход к устранению
гонок данных путём устранения общей памяти. В таком подходе различные потоки обмениваются
сообщениями через специальные абстракции и структуры данных, о которых поговорим попозже.

Общее владение памятью - это очень сложный объект обсуждения, из-за которого возникает множество
классов проблем:
- гонка данных
- use-after-free (преждевременное освобождение памяти)
- утечка памяти (как самостоятельная проблема, так и последствие)
- дедлоки
Shared Pointer призван справляться с use-after-free и утечкой памяти (но не всегда это возможно).
Shared Pointer ведёт счётчик своих копий, и когда для последней копии будет вызван деструктор, в
ветке по критерию значения счётчика память будет высвобождена. Помимо этого, shared pointer никак не
упрощает жизнь при параллельном программировании.

Иногда применение указателя не требует строго его выделения, например в ситуации сообщения метрик.
Для себя это можно понимать как ситуации, когда не требуется владение памятью, а достаточно её
заимствования. В таких ситуациях использовать `std::shared_ptr` нецелесообразно, так как обычно
такие объекты живут на протяжении всего времени работы программы, и владение памятью этим объектом
приведёт к недетектируемой утечке памяти (память доступна, но её можно освободить за ненадобностью).
В таких ситуациях стоит применять `std::weak_ptr`. `std::weak_ptr` предоставляет механизмы по
временному получению `std::shared_ptr`, который уже будет гарантировать доступность памяти

### Пример

```cpp
class MyClass {
// implementation
};

// this function will invalidate passed unique_ptr and return a valid one
std::unique_ptr<MyClass> take_own(std::unique_ptr<MyClass> ptr) { return ptr; }

int main() {
	std::unique_ptr<MyClass> o = std::make_unique<MyClass>(); // impossible to copy
	std::shared_ptr<MyClass> oo = std::make_shared<MyClass>();
	std::shared_ptr<int> spt = gw.lock()
	std::unique_ptr<MyClass[]> dynArr(new MyClass[5]);
};
	
```

## Задание

1. Реализуйте шаблон класса `UniquePtr`. Необходимо запретить копирование умного указателя путём
явного удаления конструкторов копирования: `UniquePtr(const UniquePtr&) = delete;`

```cpp
template <typename T>
class UniquePtr {
public:
    UniquePtr();
    explicit UniquePtr(T* ptr);
    UniquePtr(const UniquePtr&) = delete;
	UniquePtr(UniquePtr&) = delete;
    UniquePtr(UniquePtr&& r);
    ~UniquePtr();
	
    auto operator=(UniquePtr&& r) -> UniquePtr&;

    // проверяет, указывает ли указатель на объект
    operator bool() const;
    auto operator*() const -> T&;
    auto operator->() const -> T*;
    
    auto get() -> T*;
    void reset();
    void reset(T* ptr);
    void swap(UniquePtr& r);
};
```

2. Реализуйте шаблон класса `SharedPtr`. Для счетчика ссылок используйте переменную класса
`std::atomic_uint`. Интерфейс работы с этим классом аналогичен работе с переменной типа
`unsigned int`, т.е. к нему применимы операции префиксного инкремента и декремента.

```cpp
template <typename T>
class SharedPtr {
public:
    SharedPtr();
    explicit SharedPtr(T* ptr);
    SharedPtr(const SharedPtr& r);
    SharedPtr(SharedPtr&& r);
    ~SharedPtr();
    auto operator=(const SharedPtr& r) -> SharedPtr&;
    auto operator=(SharedPtr&& r) -> SharedPtr&;

    // проверяет, указывает ли указатель на объект
    operator bool() const;
    auto operator*() const -> T&;
    auto operator->() const -> T*;
    
    auto get() -> T*;
    void reset();
    void reset(T* ptr);
    void swap(SharedPtr& r);
    // возвращает количество объектов SharedPtr, которые ссылаются на тот же управляемый объект
    auto use_count() const -> size_t;
};
```

3. Реализуйте unit-тесты. Для `UniquePtr` требуется проверить инвалидацию указателя после передачи
в функцию. Для `SharedPtr` требуется проверить работу счётчика при вызове разных методов класса


## Рекомендации
Подробное объяснение об устройстве `unique_ptr` и `shared_ptr` можно прочитать в книге "Эффективный и современный С++" Скотта Мейерса или на соответсвующей лекции по Алгоритмическим Языкам. 
